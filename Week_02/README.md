## 实现一个地图编辑器
- 使用Array(10000).fill(0)来初始化一个一维数组来表示一个100*100的地图
- 使用localStorage缓存数组
- 注意container要加上行高、
- <div id="container"></div>container内部不要留有空格，否则会被浏览器识别为一个文本节点

## 用广度优先搜索完成寻路算法
- 地图上，每个格点都有邻居，除了地图四个角的四个格点只有两个邻近格点和四条边的格点只有三个邻近格点外都可以往前后左右四个邻近格点走，那么从起始点出发每走一步都可以有多个方向的格点可以选择，这种情况类似一颗树结构，可以使用广度优先搜索遍历整个树，直到遍历的节点是终点即可完成搜索寻路的过程
- 使用队列来存储每次走一步的前后左右的格点坐标，在队尾不断入队每走一步格点前后左右的格点坐标，并不断从队列顶部出队检查是否是终点坐标，如果是循环结束

## 通过异步编程可视化寻路算法
- 使用async await 和sleep函数延迟时间，并将寻路过程中的格点变色方便直观显示广度优先搜索的过程

## 处理路径问题
- 通过table这个数组来保存遍历过程中所有节点对应的先前节点（父节点）坐标，在找到终点坐标节点后，找到终点节点的先前节点（父节点）通过while循环不断回溯父节点直到找到起始节点为止，即可找到最短路径
## 启发式搜索
- 启发式搜索的目的是寻找最优路径，在这里最短路径即为最优路径，在每次走下一步前判断四个方向格点距离终点最近的格点，并只遍历搜索这些距离终点最近的格点就可以找到最优路径
- 启发式搜索的关键是数据结构，将原来的队列结构中傻瓜式按照顺序依次出队遍历改成每次只取（出队）队列中距离终点最优的格点坐标，即需要一个最优队列的数据结构
- 修正最短路径的细节问题，我想在我的观察中发现问题应该出现在斜向，从一个格点A斜向向下走一格走到B再向斜向向上走一格走到C的长度为2√2，而从A直接到C的直线距离2，这是需要优化的地方。这是因为每次只取距离终点最近的点，显然这个时候斜向的点距离终点更近，每次只是对一步进行优化，无法对走多步进行最优选择，解决方案暂无
- 将最优队列这种数据结构改成二叉堆的堆排序来取出最优格点的效率更高

