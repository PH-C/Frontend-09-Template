学习笔记
## 字典树
Trie树

3499

0015

0002

0007

| 字符串 |  第1层  | 第2层    |  第3层  |   第4层  |
| ------- | ------- | ------- | -------  | ------- |
|  3499   |   3    |     4    |     9    |     9   |
|  0015   |        |          |     1    |     5   |
|  0002   |   0    |     0    |     0    |     2   |
|  0007   |        |          |          |     7   |
通过分析构建树状结构，查找字符串时就像我们查字典一样顺着树的节点往下查找

## KMP算法
 KMP是字符串的模式匹配算法，就是查一个字符串（文本串）里有没有另一个字符串（模式串）

  文本串：aabaabaaf

  模式串：aabaaf

  kmp算法的关键是算出模式串各个子串的最大相等前后缀的长度，并以此生成跳转表即常见的说法next数组或prefix数组

  从左至右分析模式串的过程：
| 模式串子串     | 最大相等前后缀    | 最大相等前后缀长度 |
| ------------- | -------------    |------------- |
|  a            |     0            |        0    |
|  aa           |     [a][a]       |        1    |
|  aab          |     0            |        0    |
|  aaba         | [a]aba  aab[a]   |        1    |
|  aabaa        | [aa]baa  aab[aa] |        2    |
|  aabaaf       |     0            |        0    |

生成跳转表[0,1,0,1,2,0]、跳转表有几种表达方式例如[0,0,1,0,1,2]（此种方式分析的是当前字符前面的子串的最大相等前后缀）

跳转表的作用，当遍历模式串逐个从左到右与文本串进行对比，当出现两者字符不同时，通过跳转表找到当前模式串字符的对应的跳转表值，并从该跳转位置开始与文本串进行对比，而不需要一步一步进行对比，这种方式的时间复杂度为O(m+n),相比傻瓜式逐个匹配的时间复杂度O(m*n)要快速的多。

## Wildcard 
通配符匹配
-  “?”匹配任何一个非空字符
-  “*”匹配任意长度的字符串（包括空字符串）

ab*c?d*abc*a?d

- 只有*：ab*cd*abc*a?d
- 只有?：c?d, a?d

